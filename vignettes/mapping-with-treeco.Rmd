---
title: "Mapping with treeco"
author: "Tyler Littlefield"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Tree datasets are often spatial datasets, they contain x and y coordinates that represent a trees location. In this vignette, I'll be going over a minimal workflow for mapping tree benefits. This approach can be summarized with a few bullet points:

1. Import the data
2. Prepare the data (necessary for non spatial data formats)
3. Calculate the benefits
4. Join benefits back to the original data
5. Start mapping

## Import the data

The first step is to identify the format of the data by looking at the files extension. Below is a list of the common formats I've ran into:

1. A shapefile (`.shp`) that contains 4 or more files (yuck).
2. A text file with comma-separated values (`.csv`). 
3. An excel file (`.xlsx`, `.xls`).
4. A geopackage (`.gpkg`).

For spatial data formats we use `st_read` from the `sf` package:

```{r, message=FALSE}
library(sf)
library(dplyr)

# Source: http://cambridgegis.github.io/gisdata.html
street_trees <- st_read("https://raw.githubusercontent.com/cambridgegis/cambridgegis_data/master/Environmental/Trees/ENVIRONMENTAL_StreetTrees.topojson")
```

Notice that the format isn't even one I listed, it's a `.topojson`. This is one thing that's super awesome about `sf`, the `st_read` function guesses what format it is based on the extension.

## Prepare the data

If the input data is a spreadsheet (`.csv` or `.xlsx` for example), you will need to convert it to an `sf` object. I will not go into much detail on how to do that because the `sf` documentation is great. Please see this [reference](https://r-spatial.github.io/sf/reference/st_as_sf.html) for more information.

## Calculate the benefits

Once the data is imported, we can calculate the benefits if all 4 requirements are met:

1. We have a field for common name
2. We have a field for botanical name
3. We have a field for DBH measurements
4. We know the region code for the location of the data

If you are missing one of the name fields, use `eco_guess` to guess it. See the [getting started](https://treeco.netlify.com/articles/treeco.html) page for more information on how `eco_guess` works.

However, most tree inventory data satisfies all these requirements, so we are good to go:

```{r}
library(treeco)

tree_benefits <- eco_run_all(
  data = street_trees[1:1000, ], 
  common_col = "CommonName", 
  botanical_col = "xCartegraphSpecies", 
  dbh_col = "diameter", 
  region = "NoEastXXX",
  print_time = TRUE
  )

as_tibble(tree_benefits)
```

## Join benefits back to the original data

The first thing you'll notice is that a dataset with 50+ fields has been stripped down to 9. This is because `eco_run_all` selects what it needs and discards the rest in an effort to speed up the calculations. Additionally, `eco_run_all` creates a variable *rn* that preserves the row number of the input data. This allows you to join the benefit data back to the original data. The resulting dataframe containg the benefits and the leftover variables that `eco_run_all` removed. I typically do this with the following lines:

```{r}
library(tibble)

street_trees <- street_trees %>% 
  rownames_to_column("rn") %>% 
  right_join(tree_benefits, by = "rn") %>% 
  select(rn, common:dollars, notes, MemTree, OverheadWires, SolarRating, Ownership, Location, trunks, geometry) %>% 
  janitor::clean_names("snake") %>% 
  mutate_if(is.factor, as.character) %>% 
  st_set_crs(4326) %>% 
  st_transform(3857)
```

Note that some of the lines aren't necessary. You don't need to convert the variables names to snake case, convert all factors to character, or change the coordinate reference system. These are all just things I prefer to do. It's up to you if you want to include those bits.

## Start mapping

So far we have: imported the data, calculated the benefits, and joined those benefits back to the original dataset. Now the fun begins, we can start visualizing the results.

```{r}
library(tidyr)

street_trees %>% 
  select(rn, common, benefit, benefit_value, geometry) %>%
  spread(key = benefit, value = benefit_value) %>% 
  select(-c(rn, common)) %>% 
  plot(max.plot = 15, pch = 20)
```

```{r}
street_trees %>% 
  distinct(rn, .keep_all = TRUE) %>% 
  select(common, dbh, mem_tree, overhead_wires, solar_rating, ownership, geometry) %>% 
  plot(pch = 20)
```


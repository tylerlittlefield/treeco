---
title: "How it works"
author: "Tyler Littlefield"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<img src="https://raw.githubusercontent.com/tyluRp/treeco/master/docs/reference/figures/flowchart.png" width=700 />

Above is a very broad, high level model of how `eco_run_all` works. There is still a lot more going on behind the scenes. Specifically, there are 8 utility functions that make up `eco_run_all`, in order they are:

1. [`extract_data`](https://github.com/tyluRp/treeco/blob/master/R/utils-extract_data.R): Prepares the tree, benefits, species, and money datasets.
2. [`extract_matches`](https://github.com/tyluRp/treeco/blob/master/R/utils-extract_matches.R): Converts user data to i-Tree species names.
    * [`string_dist`](https://github.com/tyluRp/treeco/blob/master/R/utils-string_dist.R): Calculates the similarity between strings.
3. [`extract_parameters`](https://github.com/tyluRp/treeco/blob/master/R/utils-extract_parameters.R): The logic for identifying DBH ranges and extracting parameters necessary for interpolating benefits.
4. [`extract_benefits`](https://github.com/tyluRp/treeco/blob/master/R/utils-extract_benefits.R): A small wrapper around `eco_interp` with an `ifelse` to avoid interpolating over a horizontal.
    * [`eco_interp`](https://github.com/tyluRp/treeco/blob/master/R/utils-eco_interp.R): Interpolation function, $\text{benefits} = ((x - x1) * (y2 - y1) / (x2 - x1)) + y1$
5. [`extract_money`](https://github.com/tyluRp/treeco/blob/master/R/utils-extract_money.R): Creates dollars column that multiplies the benefit values by there conversion value.
6. [`capitalize`](https://github.com/tyluRp/treeco/blob/master/R/utils-capitalize.R): Capitalizes all the species names. They are normalized in `extract_matches` to improve `string_dist`'s performance.

## `extract_data`

Takes the following form:

```r
extract_data(
  data = tree_data, # or a path to a CSV
  common_col = "common_field_name", 
  botanical_col = "botanical_field_name", 
  dbh_col = "dbh_field_name", 
  region = "region_code", 
  unit "in" # or cm for centimeters
  )
```

The first thing it checks is whether or not `data` is a `data.frame` using `inherits` (i.e. is `data.frame` a class which `data` inherits?). If it is, it's converted to a `data.table` and if it's not, it's assumed to be a CSV and imported with `fread`:

```r
ifelse(
  test = inherits(data, "data.frame"),
  yes = trees <- data.table::as.data.table(data, keep.rownames = TRUE),
  no = trees <- data.table::fread(data)
)
```

Next, any rows that are missing a common or botanical name are discarded:

```r
trees <- trees[!with(trees, is.na(trees[[common_col]]) | is.na(trees[[botanical_col]])), ]
```

Next, all required datasets are saved as `data.table`'s and the money dataset is filtered by region, `melt`ed to convert from wide to long and selects the variables we need:

```r
benefits <- data.table::as.data.table(treeco::benefits)
species  <- data.table::as.data.table(treeco::species)
money    <- data.table::as.data.table(treeco::money)
money    <- money[money$region_code == region, ]
money    <- data.table::melt(money, id.vars = c("region_code", "region_name"))
money    <- money[, c("variable", "value")]
```

Next, the names of the trees dataset are set to keep naming consistent from this point going forward:

```r
data.table::setnames(trees, botanical_col, "botanical_name")
data.table::setnames(trees, common_col, "common_name")
data.table::setnames(trees, dbh_col, "dbh_val")
```

Next, datatypes are assigned and tested. If the region code doesn't exist, the function stops and gives an error:

```r
trees$botanical_name <- as.character(trees$botanical_name)
trees$common_name <- as.character(trees$common_name)
trees$dbh_val <- as.numeric(trees$dbh_val)

# Assert that the common_name is character, the dbh column is numeric, and
# the region parameter exists.
stopifnot(
  is.character(trees$botanical_name),
  is.character(trees$common_name),
  is.numeric(trees$dbh_val),
  region %in% unique(treeco::money$region_code)
) 
```

Next, only the necessary tree columns are selected. Any record with a DBH <= 0 are discarded. Benefits and species datasets are filtered by region (this should probably be lumped up above where the money dataset is filtered):

```r
trees <- trees[, .SD, .SDcol = c("rn", "common_name", "botanical_name", "dbh_val")][trees$dbh_val > 0]
benefits <- benefits[benefits$species_region == region]
species <- species[species$species_region == region]
```

Next, if the users assigns `unit = "cm"`, the DBH values will not be converted to centimeters, if no argument is given `unit` defaults to inches and converts DBH values to centimeters. This is required because i-Tree uses centimeters:

```r
ifelse(
  test = unit == "in",
  yes = trees$dbh_val <- trees$dbh_val * 2.54,
  no = trees
  )
```

Finally, the output is stored as a list to be used by `extract_matches`:

```r
output <- list(
  trees = trees,
  benefits = benefits,
  species = species,
  money = money
)

return(output)
```

**Unfinished, to be continued...**


